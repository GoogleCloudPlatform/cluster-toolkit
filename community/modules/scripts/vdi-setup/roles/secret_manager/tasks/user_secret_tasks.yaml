# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# =============================================================================
# USER SECRET MANAGEMENT TASKS
# =============================================================================
#
# This file handles user password management with Secret Manager integration.
#
# Password Sources:
# - "secret": Use existing Secret Manager secret (auto-creates if missing)
# - "password": Use provided password value (not currently used)
# - "generate": Generate random password
#
# Auto-Creation Behavior:
# - If a secret is referenced but doesn't exist, it will be automatically created
# - A secure random password will be generated and stored in the new secret
# - This ensures deployments never fail due to missing secrets
# - Auto-created secrets are treated as password changes for user provisioning
#
# =============================================================================
---

- name: Compute default secret_name if none provided
  set_fact:
    secret_name: "vdi-user-password-{{ item.username }}-{{ deployment_name }}"
  when:
  - item.password is not defined
  - item.secret_name is not defined

- name: Determine password source for user {{ item.username }}
  ansible.builtin.set_fact:
    password_source: >-
      {%- if item.secret_name is defined -%}secret
      {%- elif item.password is defined -%}password
      {%- else -%}generate{%- endif -%}

- name: Clean password source value
  ansible.builtin.set_fact:
    password_source: "{{ password_source | trim }}"

- name: Debug password source for {{ item.username }}
  ansible.builtin.debug:
    msg: |
      Password source for {{ item.username }}:
        - password_source: "{{ password_source }}"
        - secret_name: {{ item.secret_name | default('not set') }}
        - password: {{ item.password | default('not set') }}
  when: debug

- name: Fetch existing Secret Manager password for user {{ item.username }}
  ansible.builtin.uri:
    url: "https://secretmanager.googleapis.com/v1/projects/{{ item.secret_project | default(project_id) }}/secrets/{{ item.secret_name }}/versions/latest:access"
    method: GET
    headers:
      Authorization: "Bearer {{ access_token_result.json.access_token }}"
      Content-Type: "application/json"
    return_content: true
  register: sm_result
  failed_when: false
  when: password_source == "secret"

- name: Debug Secret Manager fetch result for {{ item.username }}
  ansible.builtin.debug:
    msg: |
      Secret Manager fetch for {{ item.username }}:
        - status: {{ sm_result.status }}
        - success: {{ sm_result.status == 200 }}
        - user_hash_matches: {{ user_hash_matches | default(false) }}
        - password_source: {{ password_source }}
  when: debug and password_source == "secret"

- name: Set VDI user password from Secret Manager
  ansible.builtin.set_fact:
    vdiuser_password: "{{ sm_result.json.payload.data | b64decode }}"
  when: password_source == "secret" and sm_result.status == 200

- name: Handle missing secret - auto-create with generated password
  ansible.builtin.debug:
    msg: |
      INFO: Secret Manager secret not found for {{ item.username }}.
      Auto-creating secret '{{ item.secret_name }}' with generated password.
      This ensures the deployment continues without errors.
  when: password_source == "secret" and sm_result.status != 200

- name: Generate password for auto-created secret
  ansible.builtin.set_fact:
    vdiuser_password: "{{ lookup('password', '/dev/null length=16 chars=ascii_letters,digits') }}"
  when: password_source == "secret" and sm_result.status != 200

- name: Create missing secret for user {{ item.username }}
  ansible.builtin.uri:
    url: "https://secretmanager.googleapis.com/v1/projects/{{ item.secret_project | default(project_id) }}/secrets?secretId={{ item.secret_name }}"
    method: POST
    headers:
      Authorization: "Bearer {{ access_token_result.json.access_token }}"
      Content-Type: "application/json"
    body_format: json
    body:
      replication:
        automatic: {}
    status_code: [200, 409]  # 409 = already exists
  when: password_source == "secret" and sm_result.status != 200
  register: secret_creation

- name: Store generated password in auto-created secret
  ansible.builtin.uri:
    url: "https://secretmanager.googleapis.com/v1/projects/{{ item.secret_project | default(project_id) }}/secrets/{{ item.secret_name }}:addVersion"
    method: POST
    headers:
      Authorization: "Bearer {{ access_token_result.json.access_token }}"
      Content-Type: "application/json"
    body_format: json
    body:
      payload:
        data: "{{ vdiuser_password | b64encode }}"
  when: password_source == "secret" and sm_result.status != 200

- name: Debug auto-created secret for {{ item.username }}
  ansible.builtin.debug:
    msg: |
      Auto-created secret for {{ item.username }}:
        - secret_name: {{ item.secret_name }}
        - secret_created: {{ secret_creation.status == 200 if secret_creation is defined else 'N/A' }}
        - password_generated: {{ vdiuser_password is defined }}
        - password_length: {{ vdiuser_password | length if vdiuser_password is defined else 'N/A' }}
  when: debug and password_source == "secret" and sm_result.status != 200

- name: Check if password should be forced to update (only on existing deployments)
  ansible.builtin.set_fact:
    password_force_update: "{{ item.reset_password | default(false) and not (is_fresh_deployment | default(false)) }}"

- name: Check if password has actually changed for {{ item.username }}
  ansible.builtin.set_fact:
    password_actually_changed: "{{ user_hash_matches | default(true) or (item.reset_password | default(false) and not (is_fresh_deployment | default(false))) }}"
  when: password_source == "secret" and sm_result.status == 200

- name: Set password_actually_changed for auto-created secrets
  ansible.builtin.set_fact:
    password_actually_changed: true
  when: password_source == "secret" and sm_result.status != 200

- name: Debug password change detection for {{ item.username }}
  ansible.builtin.debug:
    msg: |
      Password change detection for {{ item.username }}:
        - user_hash_matches: {{ user_hash_matches | default(false) }}
        - password_source: {{ password_source }}
        - sm_result_status: {{ sm_result.status }}
        - reset_password: {{ item.reset_password | default(false) }}
        - is_fresh_deployment: {{ is_fresh_deployment | default(false) }}
        - password_force_update: {{ password_force_update }}
        - password_actually_changed: {{ password_actually_changed | default(false) }}
        - vdiuser_password_set: {{ vdiuser_password is defined }}
  when: debug and password_source == "secret"

- name: Generate random password for user {{ item.username }}
  ansible.builtin.set_fact:
    vdiuser_password: "{{ lookup('password', '/dev/null length=16 chars=ascii_letters,digits') }}"
  when: password_source == "generate"

- name: Set user password from provided value
  ansible.builtin.set_fact:
    vdiuser_password: "{{ item.password }}"
  when: password_source == "password"

- name: Set password_actually_changed for generate and password sources
  ansible.builtin.set_fact:
    password_actually_changed: "{{ not user_hash_matches | default(true) or (item.reset_password | default(false) and not (is_fresh_deployment | default(false))) }}"
  when: password_source in ["generate", "password"]

- name: Debug final password decision for {{ item.username }}
  ansible.builtin.debug:
    msg: |
      Final password decision for {{ item.username }}:
        - password_source: {{ password_source }}
        - user_hash_matches: {{ user_hash_matches | default(false) }}
        - reset_password: {{ item.reset_password | default(false) }}
        - is_fresh_deployment: {{ is_fresh_deployment | default(false) }}
        - password_actually_changed: {{ password_actually_changed | default(false) }}
        - vdiuser_password_set: {{ vdiuser_password is defined }}
        - password_length: {{ vdiuser_password | length if vdiuser_password is defined else 'N/A' }}
  when: debug

- name: Create secret for user {{ item.username }} (provided password)
  ansible.builtin.uri:
    url: "https://secretmanager.googleapis.com/v1/projects/{{ item.secret_project | default(project_id) }}/secrets?secretId=vdi-user-password-{{ item.username }}-{{ deployment_name }}"
    method: POST
    headers:
      Authorization: "Bearer {{ access_token_result.json.access_token }}"
      Content-Type: "application/json"
    body_format: json
    body:
      replication:
        automatic: {}
    status_code: [200, 409]  # 409 = already exists
  when: password_source == "password"

- name: Store provided password in Secret Manager for user {{ item.username }}
  ansible.builtin.uri:
    url: "https://secretmanager.googleapis.com/v1/projects/{{ item.secret_project | default(project_id) }}/secrets/vdi-user-password-{{ item.username }}-{{ deployment_name }}:addVersion"
    method: POST
    headers:
      Authorization: "Bearer {{ access_token_result.json.access_token }}"
      Content-Type: "application/json"
    body_format: json
    body:
      payload:
        data: "{{ item.password | b64encode }}"
  when: password_source == "password"

- name: Create secret for user {{ item.username }}
  ansible.builtin.uri:
    url: "https://secretmanager.googleapis.com/v1/projects/{{ item.secret_project | default(project_id) }}/secrets?secretId={{ item.secret_name | default(secret_name) }}"
    method: POST
    headers:
      Authorization: "Bearer {{ access_token_result.json.access_token }}"
      Content-Type: "application/json"
    body_format: json
    body:
      replication:
        automatic: {}
    status_code: [200, 409]  # 409 = already exists
  when: password_source == "generate"

- name: Store generated password in Secret Manager for user {{ item.username }}
  ansible.builtin.uri:
    url: "https://secretmanager.googleapis.com/v1/projects/{{ item.secret_project | default(project_id) }}/secrets/{{ item.secret_name | default(secret_name) }}:addVersion"
    method: POST
    headers:
      Authorization: "Bearer {{ access_token_result.json.access_token }}"
      Content-Type: "application/json"
    body_format: json
    body:
      payload:
        data: "{{ vdiuser_password | b64encode }}"
  when: password_source == "generate"

# Note: Auto-creation logic above handles all missing secret scenarios
# This includes both fresh deployments and reset_password scenarios

- name: Set VNC configuration for user
  ansible.builtin.set_fact:
    vnc_config: >-
      {{
        (vnc_flavor | lower in ['tightvnc', 'tigervnc'])
        | ternary({
            'vncserver_password': lookup('community.general.random_string', length=8, special=false),
            'display_number': item.port | int - 5900
          }, {})
      }}

- name: Build enriched user list
  ansible.builtin.set_fact:
    vdi_users_updated: >-
      {{
        (vdi_users_updated | default([]))
        + [
          item
          | combine({ 'password': vdiuser_password })
          | combine(vnc_config)
        ]
      }}
