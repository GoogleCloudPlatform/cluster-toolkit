# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
---

# Check if this role should run
- name: Set current role for lock manager check
  ansible.builtin.set_fact:
    current_role: "secret_manager"

- name: Check if secret_manager role should run
  ansible.builtin.import_role:
    name: lock_manager
    tasks_from: check_lock

- name: Set role variables from lock manager facts
  ansible.builtin.set_fact:
    role_should_run: "{{ role_should_run | default(false) }}"
    is_fresh_deployment: "{{ is_fresh_deployment | default(false) }}"
    deployment_hash: "{{ current_deployment_hash | default('none') }}"
    user_hash: "{{ current_user_secrets_hash | default('none') }}"
    lock_file_stat: "{{ lock_file_stat | default({}) }}"
    vdi_setup_status: "{{ vdi_setup_status | default({}) }}"

- name: Debug role variables
  ansible.builtin.debug:
    msg: |
      Secret Manager role variables:
        - role_should_run: {{ role_should_run }}
        - is_fresh_deployment: {{ is_fresh_deployment }}
        - deployment_hash: {{ deployment_hash }}
        - user_hash: {{ user_hash }}
        - execution_reason: {{ 'Fresh deployment' if is_fresh_deployment else ('Hash mismatch' if not role_should_run else 'Normal role execution') }}
  when: debug

# Skip all tasks if role should not run
- name: Skip secret_manager tasks if role should not run
  ansible.builtin.debug:
    msg: "Skipping secret_manager role - already completed or not needed"
  when: not role_should_run

# Run secret manager tasks only if needed
- name: Run secret manager tasks
  block:
  # General secret handling
  - name: Generate random database password
    ansible.builtin.set_fact:
      database_password: "{{ lookup('password', '/dev/null length=32 chars=ascii_letters,digits') }}"

  - name: Get access token for Secret Manager API
    ansible.builtin.uri:
      url: "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token"
      method: GET
      headers:
        Metadata-Flavor: Google
      return_content: true
    register: access_token_result

  # Webapp admin password handling
  - name: Fetch existing webapp admin password from Secret Manager
    ansible.builtin.uri:
      url: "https://secretmanager.googleapis.com/v1/projects/{{ secret_project }}/secrets/webapp-server-password-{{ deployment_name }}/versions/latest:access"
      method: GET
      headers:
        Authorization: "Bearer {{ access_token_result.json.access_token }}"
        Content-Type: "application/json"
      return_content: true
    register: webapp_admin_sm_result
    failed_when: false

  - name: Set webapp admin password from Secret Manager (if available and not resetting)
    ansible.builtin.set_fact:
      webapp_admin_password: "{{ webapp_admin_sm_result.json.payload.data | b64decode }}"
      webapp_password_was_fetched: true
    when:
    - webapp_admin_sm_result.status == 200
    - not (reset_webapp_admin_password | default(false))

  - name: Generate new webapp admin password (if not available from Secret Manager or reset requested)
    ansible.builtin.set_fact:
      webapp_admin_password: "{{ lookup('password', '/dev/null length=32 chars=ascii_letters,digits') }}"
      webapp_password_was_fetched: false
    when:
    - webapp_admin_sm_result.status != 200 or (reset_webapp_admin_password | default(false))

  - name: Compute Webapp admin password hash to save to Webapp server
    ansible.builtin.set_fact:
      webapp_admin_hash: "{{ webapp_admin_password | hash('sha256') | upper }}"

  - name: Create a GCP secret for webapp server login
    ansible.builtin.uri:
      url: "https://secretmanager.googleapis.com/v1/projects/{{ secret_project }}/secrets?secretId=webapp-server-password-{{ deployment_name }}"
      method: POST
      headers:
        Authorization: "Bearer {{ access_token_result.json.access_token }}"
        Content-Type: "application/json"
      body_format: json
      body:
        replication:
          automatic: {}
      status_code: [200, 409]  # 409 = already exists
    register: webapp_secret_create

  - name: Add webapp password version to secret (only if new password was generated)
    ansible.builtin.uri:
      url: "https://secretmanager.googleapis.com/v1/projects/{{ secret_project }}/secrets/webapp-server-password-{{ deployment_name }}:addVersion"
      method: POST
      headers:
        Authorization: "Bearer {{ access_token_result.json.access_token }}"
        Content-Type: "application/json"
      body_format: json
      body:
        payload:
          data: "{{ webapp_admin_password | b64encode }}"
    register: webapp_secret
    when: not (webapp_password_was_fetched | default(false))

  - name: Debug webapp admin password handling
    ansible.builtin.debug:
      msg: |
        Webapp admin password handling (secret_manager):
          - reset_requested: {{ reset_webapp_admin_password | default(false) }}
          - is_fresh_deployment: {{ is_fresh_deployment | default(false) }}
          - reset_applied: {{ reset_webapp_admin_password | default(false) }}
          - secret_manager_status: {{ webapp_admin_sm_result.status }}
          - password_source: {{ 'Secret Manager' if webapp_admin_sm_result.status == 200 and not (reset_webapp_admin_password | default(false)) else 'Generated' }}
          - password_was_fetched: {{ webapp_password_was_fetched | default(false) }}
          - password_length: {{ webapp_admin_password | length if webapp_admin_password is defined else 'N/A' }}
          - stored_in_secret_manager: {{ not (webapp_password_was_fetched | default(false)) }}
    when: debug

  - name: Create a GCP secret for database password
    ansible.builtin.uri:
      url: "https://secretmanager.googleapis.com/v1/projects/{{ secret_project }}/secrets?secretId=db-password-{{ deployment_name }}"
      method: POST
      headers:
        Authorization: "Bearer {{ access_token_result.json.access_token }}"
        Content-Type: "application/json"
      body_format: json
      body:
        replication:
          automatic: {}
      status_code: [200, 409]  # 409 = already exists
    register: database_secret_create

  - name: Add database password version to secret
    ansible.builtin.uri:
      url: "https://secretmanager.googleapis.com/v1/projects/{{ secret_project }}/secrets/db-password-{{ deployment_name }}:addVersion"
      method: POST
      headers:
        Authorization: "Bearer {{ access_token_result.json.access_token }}"
        Content-Type: "application/json"
      body_format: json
      body:
        payload:
          data: "{{ database_password | b64encode }}"
    register: database_secret

  # Per-user secret handling
  - name: Generate per-user secrets and enrich list
    include_tasks: user_secret_tasks.yaml
    loop: "{{ vdi_users }}"
    loop_control:
      loop_var: item

  - name: Set enriched vdi_users_updated variable
    ansible.builtin.set_fact:
      vdi_users_updated: "{{ vdi_users_updated }}"
    when: vdi_users_updated is defined

  when: role_should_run

# Mark role as completed
- name: Set current role for lock manager completion
  ansible.builtin.set_fact:
    current_role: "secret_manager"
    role_completed: true
  when: role_should_run

- name: Mark secret_manager role as completed
  ansible.builtin.import_role:
    name: lock_manager
    tasks_from: create_lock
  when: role_should_run
